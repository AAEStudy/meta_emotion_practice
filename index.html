<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Meta-Emotion Task</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- jsPsych v7 -->
  <link href="https://unpkg.com/jspsych@7.3.4/css/jspsych.css" rel="stylesheet" />
  <script src="https://unpkg.com/jspsych@7.3.4"></script>

  <!-- Plugins -->
  <script src="https://unpkg.com/@jspsych/plugin-preload@1.1.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@1.1.3"></script>

  <style>
    body { background: black; }
    .fixation { color: white; font-size: 64px; text-align:center; }
    .center { color: white; text-align: center; }
  </style>
</head>
<body></body>

<script>
// Meta-Emotion Task (jsPsych 7) — CSV-driven
// Exports Matlab-style CSVs at the end:
//   Meta_emotion_caliprac_<subject>_<yyyy-mm-dd_HH.MM>.csv   (practice; optional but included)
//   Meta_emotion_cali_<subject>_<yyyy-mm-dd_HH.MM>.csv       (calibration)
//   Meta_emotion_metaJ_<subject>_<yyyy-mm-dd_HH.MM>.csv      (meta-judgment)
//
// Repo structure expected:
//   index.html
//   lists/ practice_pairs.csv, calibration_pairs.csv, review_list.csv, meta_list.csv
//   stimuli/ practice/<images>, formal/<images>
//   assets/ <instruction images>

// ----------------------------
// Config (timings mirror Matlab scripts)
// ----------------------------
const TIMING = {
  pic_ms: 500,      // picture duration in 2IFC + meta
  fix_ms: 500,      // fixation duration
  iti_ms: 500,      // inter-trial interval
  review_ms: 500    // paper uses 500ms in review; change if needed
};

const KEYS = {
  start: [" "],                 // space
  choice12: ["1", "2"],         // 1/2 keys
  conf1234: ["1", "2", "3", "4"]// confidence
};

// Adjust these folders if you change your repo structure
const PATHS = {
  assets: "assets/",
  practice: "stimuli/practice/",
  formal: "stimuli/formal/",
  lists: "lists/"
};

// ----------------------------
// Utilities
// ----------------------------
function pad2(n){ return String(n).padStart(2, "0"); }
function matlabTimestamp(d=new Date()){
  // yyyy-mm-dd_HH.MM
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}_${pad2(d.getHours())}.${pad2(d.getMinutes())}`;
}
function basenameMaybe(x) {
  const s = String(x || "").trim();
  if (!s) return s;
  const parts = s.split(/[/\\]/);
  return parts[parts.length - 1].trim();
}
function picIdFromFilename(filename){
  // "2019.jpg" -> 2019
  const base = basenameMaybe(filename);
  const m = base.match(/\d+/);
  return m ? Number(m[0]) : NaN;
}
function noteNumFromString(note){
  // "A12" -> 12, "P3" -> 3
  const m = String(note || "").match(/\d+/);
  return m ? Number(m[0]) : NaN;
}
function downloadText(filename, text){
  const blob = new Blob([text], {type: "text/csv;charset=utf-8"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

// ----------------------------
// CSV loading + parsing helpers
// ----------------------------
async function loadCSV(url) {
  const r = await fetch(url, { cache: "no-store" });
  if (!r.ok) throw new Error(`Failed to load CSV: ${url}`);
  const text = await r.text();
  // normalize newlines + remove BOM if present
  return text.replace(/^\uFEFF/, "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
}

// Minimal CSV parser (handles quoted cells + commas inside quotes)
function parseCSV(text) {
  const rows = [];
  let row = [];
  let cell = "";
  let inQuotes = false;

  for (let i = 0; i < text.length; i++) {
    const c = text[i];
    const next = text[i + 1];

    if (c === '"' && inQuotes && next === '"') { // escaped quote
      cell += '"';
      i++;
    } else if (c === '"') {
      inQuotes = !inQuotes;
    } else if (c === "," && !inQuotes) {
      row.push(cell);
      cell = "";
    } else if (c === "\n" && !inQuotes) {
      row.push(cell);
      cell = "";
      if (row.some(v => String(v).trim().length > 0)) rows.push(row.map(v => String(v)));
      row = [];
    } else {
      cell += c;
    }
  }
  row.push(cell);
  if (row.some(v => String(v).trim().length > 0)) rows.push(row.map(v => String(v)));
  return rows;
}

function rowsToObjects(rows) {
  if (rows.length < 2) return [];
  const header = rows[0].map(h => String(h).trim());
  return rows.slice(1).map(r => {
    const obj = {};
    header.forEach((h, i) => obj[h] = String(r[i] ?? "").trim());
    return obj;
  }).filter(o => Object.values(o).some(v => String(v).trim().length > 0));
}

// For pair lists: expects columns like pic1,pic2,note OR p1,p2
function parsePairsCSV(csvText) {
  const rows = parseCSV(csvText);
  const objs = rowsToObjects(rows);
  if (objs.length === 0) return [];

  const aKey = ["pic1","p1","img1","image1","stim1"].find(k => k in objs[0]);
  const bKey = ["pic2","p2","img2","image2","stim2"].find(k => k in objs[0]);
  const nKey = ["note","cond","category","cat","pair_id"].find(k => k in objs[0]);

  if (!aKey || !bKey) {
    throw new Error(`Pair CSV must have headers like pic1,pic2 (or p1,p2). Found: ${rows[0].join(", ")}`);
  }

  return objs.map(o => ({
    p1: basenameMaybe(o[aKey]),
    p2: basenameMaybe(o[bKey]),
    note: nKey ? String(o[nKey]).trim() : ""
  })).filter(t => t.p1 && t.p2);
}

// For single-column lists: expects a column like pic/img OR uses first column
function parseSingleColumnCSV(csvText) {
  const rows = parseCSV(csvText);
  if (rows.length < 2) return [];

  const header = rows[0].map(h => String(h).trim());
  const colKey = ["pic","img","image","stim","filename","file"].find(k => header.includes(k));
  const colIndex = colKey ? header.indexOf(colKey) : 0;

  return rows.slice(1)
    .map(r => basenameMaybe(r[colIndex]))
    .filter(v => String(v).trim().length > 0);
}

// ----------------------------
// Trial builders
// ----------------------------
function fixationTrial(ms){
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `<div class="fixation">+</div>`,
    choices: "NO_KEYS",
    trial_duration: ms,
    data: {event: "fixation", duration_ms: ms}
  };
}

function blankITI(ms){
  return {
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `<div></div>`,
    choices: "NO_KEYS",
    trial_duration: ms,
    data: {event: "iti", duration_ms: ms}
  };
}

function imagePassive(stimulus, ms, extraData={}){
  return {
    type: jsPsychImageKeyboardResponse,
    stimulus,
    choices: "NO_KEYS",
    trial_duration: ms,
    data: {event: "image_passive", stimulus, duration_ms: ms, ...extraData}
  };
}

function htmlImageScreen(path, tag){
  return {
    type: jsPsychImageKeyboardResponse,
    stimulus: path,
    choices: KEYS.start,
    data: {event: tag}
  };
}

function buildTwoIntervalTrial(pic1, pic2, note, blockName){
  const pic1_id = picIdFromFilename(pic1);
  const pic2_id = picIdFromFilename(pic2);
  const note_num = noteNumFromString(note);

  return {
    timeline: [
      imagePassive(pic1, TIMING.pic_ms, {block: blockName, phase: "interval1"}),
      fixationTrial(TIMING.fix_ms),
      imagePassive(pic2, TIMING.pic_ms, {block: blockName, phase: "interval2"}),
      fixationTrial(TIMING.fix_ms),
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<div class="center" style="font-size:28px; line-height:1.35;">
                    Which picture elicited stronger <b>positive emotion</b>?<br><br>
                    Press <b>1</b> for the FIRST picture, <b>2</b> for the SECOND picture.
                  </div>`,
        choices: KEYS.choice12,
        data: {
          event: "2ifc_response",
          block: blockName,
          pic1, pic2,
          pic1_id, pic2_id,
          note: note || "",
          note_num
        },
        on_finish: (data) => {
          data.choice_key = data.response; // "1" or "2"
          data.chosen = (data.response === "1") ? pic1 : pic2;
          data.chosen_id = (data.response === "1") ? pic1_id : pic2_id;
          data.rt_ms = data.rt;
          data.start_time_ms = Date.now();
        }
      },
      blankITI(TIMING.iti_ms)
    ]
  };
}

function buildMetaJudgmentTrial(pic, blockName){
  const pic_id = picIdFromFilename(pic);

  return {
    timeline: [
      imagePassive(pic, TIMING.pic_ms, {block: blockName, phase: "stimulus"}),
      fixationTrial(TIMING.fix_ms),
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<div class="center" style="font-size:28px; line-height:1.35;">
          Compared to the <b>median</b> of the whole picture set,<br>
          did this picture induce <b>higher</b> or <b>lower</b> positive emotion?<br><br>
          Press <b>1</b> = Higher, <b>2</b> = Lower
        </div>`,
        choices: KEYS.choice12,
        data: {event: "meta_type1", block: blockName, pic, pic_id},
        on_finish: (data) => {
          data.type1_key = data.response;
          data.type1_rt_ms = data.rt;
          data.start_time_ms = Date.now();
        }
      },
      {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: `<div class="center" style="font-size:28px; line-height:1.35;">
          Confidence (1 = very unconfident … 4 = very confident)<br><br>
          Press <b>1</b> / <b>2</b> / <b>3</b> / <b>4</b>
        </div>`,
        choices: KEYS.conf1234,
        data: {event: "meta_conf", block: blockName, pic, pic_id},
        on_finish: (data) => {
          data.conf_key = data.response;
          data.conf_rt_ms = data.rt;

          const lastType1 = jsPsych.data.get().filter({event: "meta_type1", pic_id: pic_id}).last(1).values()[0];
          if (lastType1) {
            data.type1_key = lastType1.type1_key;
            data.type1_rt_ms = lastType1.type1_rt_ms;
            data.type1_start_time_ms = lastType1.start_time_ms;
          }
          data.start_time_ms = Date.now();
        }
      },
      blankITI(TIMING.iti_ms)
    ]
  };
}

// ----------------------------
// Matlab-style exports
// ----------------------------
function exportMatlabStyleCSVs(jsPsych){
  const subject = (jsPsych.data.get().values()[0]?.subject ?? "NA");
  const stamp = matlabTimestamp(new Date());

  const rowsToCSV = (rows) => rows.map(r => r.join(",")).join("\n") + "\n";

  const practiceRows = jsPsych.data.get().filter({block:"practice", event:"2ifc_response"}).values()
    .map(d => [
      Number(subject) || subject,
      d.start_time_ms ?? "",
      d.pic1_id ?? "",
      d.pic2_id ?? "",
      d.note_num ?? "",
      d.choice_key ?? "",
      d.chosen_id ?? "",
      d.rt_ms ?? ""
    ]);

  const caliRows = jsPsych.data.get().filter({block:"calibration", event:"2ifc_response"}).values()
    .map(d => [
      Number(subject) || subject,
      d.start_time_ms ?? "",
      d.pic1_id ?? "",
      d.pic2_id ?? "",
      d.note_num ?? "",
      d.choice_key ?? "",
      d.chosen_id ?? "",
      d.rt_ms ?? ""
    ]);

  const metaRows = jsPsych.data.get().filter({block:"meta", event:"meta_conf"}).values()
    .map(d => [
      Number(subject) || subject,
      d.type1_start_time_ms ?? d.start_time_ms ?? "",
      d.pic_id ?? "",
      d.type1_key ?? "",
      d.type1_rt_ms ?? "",
      d.conf_key ?? "",
      d.conf_rt_ms ?? ""
    ]);

  if (practiceRows.length) downloadText(`Meta_emotion_caliprac_${subject}_${stamp}.csv`, rowsToCSV(practiceRows));
  if (caliRows.length) downloadText(`Meta_emotion_cali_${subject}_${stamp}.csv`, rowsToCSV(caliRows));
  if (metaRows.length) downloadText(`Meta_emotion_metaJ_${subject}_${stamp}.csv`, rowsToCSV(metaRows));
}

// ----------------------------
// Main run
// ----------------------------
(async function run(){
  const jsPsych = initJsPsych({
    on_finish: () => {
      exportMatlabStyleCSVs(jsPsych);
      // Optional: jsPsych.data.get().localSave("csv", "meta_emotion_jspsych_raw.csv");
    }
  });

  const timeline = [];

  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `<div class="center" style="font-size:24px; line-height:1.35; max-width:800px; margin:0 auto;">
      <p><b>Meta-Emotion Task</b></p>
      <p>Press <b>SPACE</b> to begin.</p>
    </div>`,
    choices: KEYS.start,
    on_finish: () => {
      const subject = prompt("Subject ID (required):") || "NA";
      jsPsych.data.addProperties({ subject });
    }
  });

  const practiceCSV = await loadCSV(PATHS.lists + "practice_pairs.csv");
  const calibrationCSV = await loadCSV(PATHS.lists + "calibration_pairs.csv");
  const reviewCSV = await loadCSV(PATHS.lists + "review_list.csv");
  const metaCSV = await loadCSV(PATHS.lists + "meta_list.csv");

  const practicePairs = parsePairsCSV(practiceCSV);
  const calibrationPairs = parsePairsCSV(calibrationCSV);
  const reviewList = parseSingleColumnCSV(reviewCSV);
  const metaList = parseSingleColumnCSV(metaCSV);

  const practiceImgs = practicePairs.flatMap(t => [PATHS.practice + t.p1, PATHS.practice + t.p2]);
  const calibrationImgs = calibrationPairs.flatMap(t => [PATHS.formal + t.p1, PATHS.formal + t.p2]);
  const reviewImgs = reviewList.map(x => PATHS.formal + x);
  const metaImgs = metaList.map(x => PATHS.formal + x);

  const assetImgs = [
    "instruction.jpg",
    "endx_prac.jpg",
    "restx.jpg",
    "instruction2.jpg"
  ].map(x => PATHS.assets + x);

  const allToPreload = [...new Set([...practiceImgs, ...calibrationImgs, ...reviewImgs, ...metaImgs, ...assetImgs])];

  timeline.push({
    type: jsPsychPreload,
    images: allToPreload,
    show_progress_bar: true
  });

  timeline.push(htmlImageScreen(PATHS.assets + "instruction.jpg", "practice_instructions"));
  practicePairs.forEach((t) => {
    timeline.push(buildTwoIntervalTrial(PATHS.practice + t.p1, PATHS.practice + t.p2, t.note, "practice"));
  });
  timeline.push(htmlImageScreen(PATHS.assets + "endx_prac.jpg", "practice_end"));

  // timeline.push(htmlImageScreen(PATHS.assets + "instruction.jpg", "calibration_instructions"));
  // const REST_EVERY = 38;

  // calibrationPairs.forEach((t, idx) => {
  //   timeline.push(buildTwoIntervalTrial(PATHS.formal + t.p1, PATHS.formal + t.p2, t.note, "calibration"));
  //   if ((idx + 1) % REST_EVERY === 0 && (idx + 1) < calibrationPairs.length) {
  //     timeline.push({
  //       type: jsPsychImageKeyboardResponse,
  //       stimulus: PATHS.assets + "restx.jpg",
  //       choices: KEYS.start,
  //       data: {event: "rest_screen", block: "calibration", after_trial: idx + 1}
  //     });
  //   }
  // });

  // timeline.push({
  //   type: jsPsychHtmlKeyboardResponse,
  //   stimulus: `<div class="center" style="font-size:24px; line-height:1.35;">
  //     Next, you will re-view all pictures.<br><br>
  //     Press <b>SPACE</b> to begin.
  //   </div>`,
  //   choices: KEYS.start,
  //   data: {event: "review_instructions"}
  // });
  // reviewImgs.forEach((img) => {
  //   timeline.push(imagePassive(img, TIMING.review_ms, {block: "review"}));
  // });

  // timeline.push(htmlImageScreen(PATHS.assets + "instruction2.jpg", "meta_instructions"));
  // metaImgs.forEach((img) => {
  //   timeline.push(buildMetaJudgmentTrial(img, "meta"));
  // });
  // <!-- ===========================
  //    TEST MODE PATCH (SHORT RUN)
  //    Paste this over your CURRENT "Calibration / Review / Meta" section.
  //    It keeps the same structure but limits trial counts so you can test exports fast.
  //    =========================== -->

// ====== TEST LIMITS (ONLY CHANGE THESE NUMBERS) ======
const CALI_LIMIT  = 12;  // calibration trials to run (12 ~ ~1–2 min depending on RT)
const REVIEW_LIMIT = 5;  // number of review images to show
const META_LIMIT   = 6;  // number of meta-judgment trials (each has 2 responses)

// ====== CALIBRATION (SHORT) ======
timeline.push(htmlImageScreen(PATHS.assets + "instruction.jpg", "calibration_instructions"));

const REST_EVERY = 38; // keep same as original (won't usually trigger in short test)

// Only run first CALI_LIMIT calibration trials
calibrationPairs.slice(0, CALI_LIMIT).forEach((t, idx) => {
  timeline.push(buildTwoIntervalTrial(PATHS.formal + t.p1, PATHS.formal + t.p2, t.note, "calibration"));

  // rest screen logic adapted to the limited run
  if ((idx + 1) % REST_EVERY === 0 && (idx + 1) < CALI_LIMIT) {
    timeline.push({
      type: jsPsychImageKeyboardResponse,
      stimulus: PATHS.assets + "restx.jpg",
      choices: KEYS.start,
      data: {event: "rest_screen", block: "calibration", after_trial: idx + 1}
    });
  }
});

// ====== REVIEW (SHORT) ======
timeline.push({
  type: jsPsychHtmlKeyboardResponse,
  stimulus: `<div class="center" style="font-size:24px; line-height:1.35;">
    Next, you will re-view all pictures.<br><br>
    Press <b>SPACE</b> to begin.
  </div>`,
  choices: KEYS.start,
  data: {event: "review_instructions"}
});

// Only show first REVIEW_LIMIT review images
reviewImgs.slice(0, REVIEW_LIMIT).forEach((img) => {
  timeline.push(imagePassive(img, TIMING.review_ms, {block: "review"}));
});

// ====== META-JUDGMENT (SHORT) ======
timeline.push(htmlImageScreen(PATHS.assets + "instruction2.jpg", "meta_instructions"));

// Only run first META_LIMIT meta trials
metaImgs.slice(0, META_LIMIT).forEach((img) => {
  timeline.push(buildMetaJudgmentTrial(img, "meta"));
});


  timeline.push({
    type: jsPsychHtmlKeyboardResponse,
    stimulus: `<div class="center" style="font-size:28px; line-height:1.35;">
      Finished. Thank you!<br><br>
      Your data will download automatically.
    </div>`,
    choices: "NO_KEYS",
    trial_duration: 1500,
    data: {event: "end"}
  });

  jsPsych.run(timeline);
})();
</script>
</html>
